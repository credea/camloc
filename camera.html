<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <script src="https://telegram.org/js/telegram-web-app.js?59"></script>
    <title>Camera Submitted</title>

    <style>
      body {
        font-family: sans-serif;
        text-align: center;
        margin: 0;
        padding: 1rem;
        background: #f5f5f5;
      }

      video {
        width: 100%;
        max-width: 320px;
        border-radius: 10px;
        background: #000;
      }

      #status, #location {
        margin-top: 0.5rem;
        font-size: 0.9rem;
      }

      #debug {
        font-size: 12px;
        color: #444;
        white-space: pre-line;
      }
    </style>
  </head>

  <body>
    <h3>üì∑ Look Camera</h3>

    <video id="video" autoplay playsinline muted></video>
    <p id="status">‚è≥ Initializing camera...</p>
    <p id="location"></p>
    <p id="debug"></p>

    <script>
      const tg = window.Telegram.WebApp;
      tg.ready();
      tg.expand();

      const video = document.getElementById("video");
      const status = document.getElementById("status");
      const locText = document.getElementById("location");

      let lastLocation = null;
      let locationRetry = 0;
      const MIN_ACCURACY = 25; // meters
      const MAX_RETRY = 3;

      function debug(msg) {
        const el = document.getElementById("debug");
        el.innerText += msg + "\n";
      }

      // -------------------------
      // START CAMERA
      // -------------------------
      async function startCamera() {
        try {
          const stream = await navigator.mediaDevices.getUserMedia({
            video: { facingMode: "user" },
          });

          video.srcObject = stream;
          await video.play();

          status.innerText = "‚úÖ Camera is active";

          // Start background location lookup
          setTimeout(() => getLocationBackground(), 500);
        } catch (err) {
          status.innerText =
            "‚ùå Unable to access camera: " + err.message;
        }
      }

      startCamera();

      // -------------------------
      // GET LOCATION
      // -------------------------
      function getLocation() {
        return new Promise((resolve) => {
          if (!navigator.geolocation) return resolve(null);

          navigator.geolocation.getCurrentPosition(
            (pos) => {
              resolve({
                lat: pos.coords.latitude,
                lng: pos.coords.longitude,
                accuracy: pos.coords.accuracy,
              });
            },
            (err) => {
              tg.showAlert(
                "‚ö†Ô∏è Please enable location access.\nError: " + err.message
              );
              resolve(null);
            },
            { enableHighAccuracy: true, timeout: 5000, maximumAge: 3000 }
          );
        });
      }

      // -------------------------
      // AUTO-LOCATION BACKGROUND
      // -------------------------
      async function getLocationBackground() {
        locText.innerText = "üìç Fetching location...";
        tg.MainButton.hide();

        lastLocation = await getLocation();

        if (lastLocation) {
          locText.innerText =
            `üìç Location: ${lastLocation.lat.toFixed(5)}, ${lastLocation.lng.toFixed(5)}` +
            ` (¬±${lastLocation.accuracy.toFixed(2)}m)`;
        } else {
          locText.innerText = "üìç Location unavailable";
        }

        // GOOD ACCURACY
        if (lastLocation && lastLocation.accuracy <= MIN_ACCURACY) {
          tg.MainButton.show();
          return;
        }

        // RETRY
        if (locationRetry < MAX_RETRY) {
          locationRetry++;
          locText.innerText += `\n‚è≥ Improving accuracy... (${locationRetry})`;
          setTimeout(getLocationBackground, 3000);
        } else {
          locText.innerText += "\n‚ö†Ô∏è Location accuracy still low.";
          tg.MainButton.show();
        }
      }

      // -------------------------
      // MAIN BUTTON
      // -------------------------
      tg.MainButton.setText("‚úÖ Capture/Submit");
      tg.MainButton.show();

      tg.MainButton.onClick(async () => {
        const canvas = document.createElement("canvas");
        canvas.width = video.videoWidth;
        canvas.height = video.videoHeight;

        if (!canvas.width || !canvas.height) {
          tg.showAlert("‚ùå Camera not ready yet!");
          return;
        }

        const ctx = canvas.getContext("2d");
        ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

        status.innerText = "üì§ Submitting...";

        // Ensure we have location
        if (!lastLocation) {
          lastLocation = await getLocation();
        }

        canvas.toBlob(
          async (blob) => {
            if (!blob) return;

            const params = new URLSearchParams(window.location.search);
            const APPS_SCRIPT_URL = params.get("server_url");
            const USER_ID_FROM_URL = params.get("chat_id");

            const reader = new FileReader();
            reader.readAsDataURL(blob);

            reader.onloadend = async function () {
              const base64data = reader.result;

              const formData = new FormData();
              formData.append("photo_base64", base64data);
              formData.append("location", JSON.stringify(lastLocation));
              formData.append("user_id", USER_ID_FROM_URL);
              formData.append("timestamp", new Date().toISOString());

              try {
                await fetch(APPS_SCRIPT_URL, {
                  method: "POST",
                  mode: "no-cors",
                  body: formData,
                });
                tg.showAlert("‚úÖ Submitted!");
              } catch (e) {
                tg.showAlert("‚ùå Failed to submit");
              }
            };

            setTimeout(() => tg.sendData("ok"), 2000);
            setTimeout(() => tg.close(), 1200);
          },
          "image/jpeg",
          0.9
        );
      });
    </script>
  </body>
</html>
